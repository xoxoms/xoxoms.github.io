---
layout: post
title: About JPA (1)
---
Why use JPA?

-------------

## 영속성 프레임워크

영속성(Persistence)은 데이터가 프로세스 내에서 생성됐지만 프로세스의 생명주기와 별개로 유지되는 특성을 말하며, 파일이나 데이터베이스 같은 기억 장치에 데이터를 보존하는 것으로 실현한다.

프로그램 언어 측면에서 데이터를 영속시키는 방법은 다양한데 자바 진영에서는 SQL Mapper와 ORM 같은 기술을 이용한 영속성 프레임워크를 주로 사용한다. 

SQL Mapper는 객체와 sql을 매핑하는 데이터 중심 기술로 iBatis와 MyBatis가 있고, ORM은 객체와 테이블 간의 관계를 매핑하는 객체 중심 기술로 JPA를 구현한 하이버네이트와 eclipseLink 등이 있다. 아래는 MyBatis, JPA를 비교한 내용이다.

#### * MyBatis와 JPA의 기회비용 및 성능비교
![architecture](http://xoxoms.github.io/images/3/1.png)
![architecture](http://xoxoms.github.io/images/3/2.png)

이처럼 MyBatis와 JPA는 장단이 명확한데, 우리는 객체 지향 언어인 자바를 사용하는 개발자이니까 "Work in Object centric" 관점에서 두 기술의 차이점을 알아보자

## SQL 중심 기술과 객체 중심 기술의 비교

---

#### * 비지니스 요구사항
두 기술을 비교하기 위한 간단한 예제
    1. 회원을 관리할 수 있는 시스템을 구축해라
    2. 회원은 최초 이름과 나이 정보를 갖는다.

#### * 회원 Class
@Entity나 @Id 등의 어노테이션은 생략
```java
@Getter
@Setter
public class User {
	private Long id;
    private String name;
    private int age;
}
```

#### * 구조
Spring framework를 사용할 경우 볼수있는 일반적인 구조
![architecture](http://xoxoms.github.io/images/3/0.png)

참고로 Controller, Service 까지는 비슷한 역할을 하므로 예제에서는 Repository부터 xml과 EntityManager만 다루도록하겠다.

그럼 gogogo!

#### 1. 삽입 기능 개발

비지니스 요청사항에 맞게 삽입 기능을 개발해보자.

```java
// UserController.class는 공통
@Controller
@RepuestMapping("/user")
public UserController() {
    @RequestMapping(method=RequestMethod.POST) 
    public void save(User user){
        userService.save(user);
    }
}}
// UserService.class도 공통
@Service
public UserService() {
    public void save(User user) {
        userRepository.save(user);
    }
}
```

* MyBatis

  UserService로부터 UserRepository의 save 메소드가 호출되면 MyBatis 설정으로 인해 UserRepository와 매핑되는 UserMapper.xml의 save를 찾아서 실행하는데, 데이터베이스에 user 정보를 삽입할 수 있도록 xml을 작성하자

``` xml
<xml>
    <namespace="user"/>
    <insert id="save" parameterType="com.test.dto.User">
        insert into USER(name, age)
        values(#{name}, #{age});
    </insert>
</xml>
```

* JPA
  UserService가 UserRepository의 save 메소드만 호출하면 끝. MyBatis 처럼 xml을 작성할 필요가 없다. 삽입 sql은 JPA가 알아서 만들어준다. 

```java
@Repository
public interface UserRepository() extends SimpleJpaRepository<User.class, long> {
    void save(User user);
}
```
#### 2. 조회 기능 개발

데이터를 삽입하는 기능을 개발했으니, 삽입한 데이터를 조회하는 기능을 추가하자.

```java
// UserController.class는 공통
@Controller
@RepuestMapping("/user")
public UserController() {
    @RequestMapping("/{id}", method=RequestMethod.GET) 
    public User find(@PathVariable Long userId){
        return userService.findById(userId);
    }
}}
// UserService.class도 공통
@Service
public UserService() {
    public User findById(Long userId) {
        return userRepository.findById(userId);
    }
}
```

* MyBatis

  UserService로부터 UserRepository의 findById 메소드가 호출되면 UserRepository와 매핑되는 UserMapper.xml의 findById를 찾아서 실행하는데, 데이터베이스에서 user 정보를 조회할 수 있도록 xml을 작성하자

``` xml
<xml>
    <namespace="user"/>
    <select id="findById" parameterType="Long">
        select name, age
        from USER
        where id = #{userId};
    </select>
</xml>
```

* JPA
  UserService가 UserRepository의 findById 메소드만 호출하면 끝. MyBatis 처럼 xml을 작성할 필요가 없다. 조회 sql은 JPA가 알아서해준다. 

```java
@Repository
public interface UserRepository() extends SimpleJpaRepository<User.class, long> {
    void save(User user);
}
```
#### 3. 수정 기능 개발

삽입과 조회가 가능해졌다. 이제 수정 기능을 만들어보자 (참고로 고객은 회원 정보를 삭제하는 기능을 원하지 않기 때문에 이게 마지막이다.) 

```java
// UserController.class는 공통
@Controller
@RepuestMapping("/user")
public UserController() {
    @RequestMapping(method=RequestMethod.PUT) 
    public User find@RequestBody User user){
        return userService.update(user);
    }
}}
```

* MyBatis

  UserService로부터 UserRepository의 update 메소드가 호출되면 UserRepository와 매핑되는 UserMapper.xml의 update를 찾아서 실행하는데, 데이터베이스에서 user 정보를 수정할 수 있도록 xml을 작성하자
```java
// UserService.class 다름
@Service
public UserService() {
    public User update(User user) {
        return userRepository.update(user);
    }
}
```
``` xml
<xml>
    <namespace="user"/>
    <update id="update" parameterType="com.test.dto.User">
        update USER
            name = #{name}
            age = #{age} 
        where id = #{user.userId};
    </update>
</xml>
```

* JPA
  UserService가 UserRepository의 save 메소드만 호출하면 끝. MyBatis 처럼 xml을 작성할 필요가 없다. 수정 sql은 JPA가 알아서해준다. 
  
  참고로 EntityManager는 user의 id(식별자)가 있는 상태에서 save가 호출되면 데이터베이스에서 id로 엔티티를 조회한 후 update를 수행한다.

```java
// UserService.class 다름
@Service
public UserService() {
    public User update(User user) {
        return userRepository.save(user);
    }
}
@Repository
public interface UserRepository() extends SimpleJpaRepository<User.class, Long> {
    void save(User user);
}
```

#### 4. 요구사항의 변경

개발을 하다보면 요구사항이 변경되어 다시 개발해야하거나 잘사용하던 기능을 개선 목적이 혹은 사용하지 않는 기능의 삭제 등으로 유지보수를 해야하는 경우가 많다. 우리도 마침내 삽입, 조회, 수정 모두 개발했지만 고객으로부터 회원의 연락처를 추가해달라는 요구사항이왔다. 

이런 경우에 MyBatis와 JPA는 어떤 차이가 있을까?   

* MyBatis

  User 객체에 전화번호 field를 추가하고 User 테이블과 관련된 모든 sql에 전화번호를 추가한다.

* JPA
  
  User 객체에 전화번호 field를 추가하고 테이블의 column과 정확하게 매핑한다.

위는 간단한 예제이므로 큰 차이를 못느낄 수 있으나 JPA 개발자는 객체와 테이블 매핑만 정확하게 하면 끝나는 반면 MyBatis 개발자는 User와 관련된 class와 xml 모두를 훑어봐야하므로 큰 차이가 있다.